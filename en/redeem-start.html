<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="GPTishka: extend and activate ChatGPT Plus." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="GPTishka" />
  <meta property="og:title" content="Extend / Activate - GPTishka" />
  <meta property="og:description" content="GPTishka: extend and activate ChatGPT Plus." />
  <meta property="og:image" content="https://gptishka.shop/assets/img/logo.png" />
  <meta property="og:url" content="https://gptishka.shop/en/redeem-start.html" />
  <link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" type="image/avif" href="/favicon.avif">
<link rel="shortcut icon" href="/favicon.ico">
  <title>Extend / Activate - GPTishka</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/logo.min.css">
  <link rel="stylesheet" href="/assets/css/sections.min.css">
  <link rel="stylesheet" href="/assets/css/theme.min.css">

  <style>
    .redeem-page {
      max-width: 1080px;
      margin: 0 auto;
      padding: 20px 0 0;
    }

    .redeem-card {
      background: #fff;
      border: 1px solid rgba(25, 34, 51, 0.08);
      border-radius: 24px;
      box-shadow: 0 18px 44px rgba(25, 34, 51, 0.08);
      padding: 26px;
    }

    .redeem-title {
      margin: 0;
      font-size: clamp(30px, 4vw, 44px);
      line-height: 1.08;
      font-weight: 800;
      color: #1f2937;
    }

    .redeem-subtitle {
      margin: 10px 0 0;
      font-size: 16px;
      line-height: 1.45;
      color: #5c6778;
    }

    .redeem-grid {
      margin-top: 18px;
      display: grid;
      gap: 14px;
      grid-template-columns: 1fr;
    }

    .redeem-block {
      background: #fbfaf6;
      border: 1px solid rgba(25, 34, 51, 0.08);
      border-radius: 16px;
      padding: 14px;
    }

    .redeem-label {
      margin: 0 0 8px;
      font-size: 16px;
      font-weight: 700;
      color: #1f2937;
    }

    .redeem-order-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      border: 1px solid rgba(25, 34, 51, 0.1);
      background: #fff;
      border-radius: 12px;
      padding: 10px 12px;
    }

    .redeem-order-id {
      min-width: 0;
      font-size: 14px;
      color: #253041;
      font-weight: 700;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      max-width: 760px;
    }

    .redeem-guide {
      margin: 0 0 10px;
      border: 1px solid rgba(25, 34, 51, 0.1);
      border-radius: 12px;
      background: #fff;
      padding: 10px 12px;
      color: #3a4556;
      line-height: 1.45;
      font-size: 14px;
    }

    .redeem-guide summary {
      cursor: pointer;
      font-weight: 700;
      color: #1f2937;
    }

    .redeem-guide ol {
      margin: 8px 0 0 18px;
      padding: 0;
    }

    .redeem-guide a {
      color: #1f8f7f;
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .redeem-input {
      width: 100%;
      min-height: 150px;
      resize: vertical;
      border: 1px solid rgba(25, 34, 51, 0.14);
      border-radius: 14px;
      background: #fff;
      padding: 12px 14px;
      font: inherit;
      line-height: 1.45;
      color: #1f2937;
      outline: none;
      transition: border-color .15s ease, box-shadow .15s ease;
    }

    .redeem-input:focus {
      border-color: #1f8f7f;
      box-shadow: 0 0 0 3px rgba(31, 143, 127, 0.14);
    }

    .redeem-input.masked {
      color: transparent;
      text-shadow: 0 0 6px rgba(31, 41, 55, 0.7);
      caret-color: #1f2937;
    }

    .redeem-meta {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 13px;
      color: #667288;
    }

    .redeem-meta .warn {
      color: #b42318;
      font-weight: 700;
    }

    .redeem-actions {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .redeem-actions .full {
      grid-column: 1 / -1;
    }

    .redeem-btn {
      border: 1px solid rgba(25, 34, 51, 0.14);
      background: #fff;
      color: #243246;
      border-radius: 12px;
      padding: 10px 14px;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 44px;
      transition: background .15s ease, color .15s ease, border-color .15s ease, transform .1s ease;
    }

    .redeem-btn:hover {
      background: #f7f8fa;
      border-color: rgba(25, 34, 51, 0.2);
    }

    .redeem-btn:active {
      transform: translateY(1px);
    }

    .redeem-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    .redeem-btn-primary {
      background: #1f8f7f;
      border-color: #1f8f7f;
      color: #fff;
    }

    .redeem-btn-primary:hover {
      background: #177a6c;
      border-color: #177a6c;
      color: #fff;
    }

    .redeem-status {
      margin-top: 12px;
      border: 1px solid rgba(25, 34, 51, 0.11);
      background: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      color: #334154;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .redeem-status.pending { border-color: rgba(186, 131, 25, 0.35); background: #fff8e9; color: #9a6700; }
    .redeem-status.success { border-color: rgba(17, 120, 90, 0.35); background: #eaf7f3; color: #0f7a5d; }
    .redeem-status.error { border-color: rgba(178, 60, 60, 0.35); background: #ffefef; color: #b33f3f; }

    .redeem-spinner {
      width: 13px;
      height: 13px;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      display: none;
      animation: redeem-spin .8s linear infinite;
    }

    .redeem-faq {
      margin-top: 12px;
      border: 1px solid rgba(25, 34, 51, 0.08);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fff;
      color: #5e6a7d;
      font-size: 14px;
    }

    .redeem-btn.loading {
      pointer-events: none;
    }

    .redeem-btn.loading::after {
      content: "";
      width: 12px;
      height: 12px;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      animation: redeem-spin .8s linear infinite;
    }

    @keyframes redeem-spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 860px) {
      .redeem-actions {
        grid-template-columns: 1fr;
      }

      .redeem-actions .full {
        grid-column: auto;
      }
    }

    @media (max-width: 640px) {
      .redeem-page {
        padding-top: 14px;
      }

      .redeem-card {
        padding: 16px;
        border-radius: 18px;
      }

      .redeem-guide,
      .redeem-block {
        border-radius: 12px;
      }
    }
  </style>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=106915056', 'ym');

    ym(106915056, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", referrer: document.referrer, url: location.href, accurateTrackBounce:true, trackLinks:true});
</script>
<!-- /Yandex.Metrika counter -->
</head>
<body>
<noscript><div><img src="https://mc.yandex.ru/watch/106915056" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <div class="page-overlay"></div>

  <header>
    <div class="nav">
      <a href="/index.html" class="logo-link">
        <img loading="lazy" decoding="async" fetchpriority="high" src="/assets/img/logo.png" alt="GPT����" class="logo-img">
      </a>

      <nav>
        <a href="/index.html">�������</a>
        <a href="/about.html">� �������</a>
        <a href="/reviews.html">������</a>
        <a href="/guarantee.html">��������</a>
        <a href="/contact.html">����� � ����</a>
        <a href="/index.html#faq">������� � ������</a>
      </nav>

      <div class="lang-switch" id="langSwitch">
        <div class="lang-current" id="langCurrent">
          <img loading="lazy" decoding="async" src="/assets/img/iconeng.png" alt="">
          <span>English</span>
          <span class="arrow">?</span>
        </div>

        <div class="lang-dropdown">
          <div class="lang-item" data-lang="ru">
            <img loading="lazy" decoding="async" src="/assets/img/iconrus.avif" alt="">
            <span>�������</span>
          </div>
          <div class="lang-item" data-lang="en">
            <img loading="lazy" decoding="async" src="/assets/img/iconeng.png" alt="">
            <span>English</span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="page redeem-page">
    <section class="redeem-card">
      <h1 class="redeem-title">Extend / Activate</h1>
      <p class="redeem-subtitle">After payment, paste your account token and click �Activate�.</p>

      <div class="redeem-grid">
        <section class="redeem-block">
          <p class="redeem-label">Order ID</p>
          <div class="redeem-order-row">
            <span id="orderId" class="redeem-order-id">-</span>
            <button id="copyOrderIdBtn" type="button" class="redeem-btn">Copy</button>
          </div>
        </section>

        <section class="redeem-block">
          <p class="redeem-label">Account token</p>
          <details class="redeem-guide" open>
            <summary>Where to get the account token</summary>
            <ol>
              <li>Sign in to ChatGPT in your browser.</li>
              <li>Open <a href="https://chatgpt.com/api/auth/session" target="_blank" rel="noreferrer noopener">chatgpt.com/api/auth/session</a></li>
              <li>Copy the full content and paste it into the �Account token� field.</li>
              <li>How it works / video instruction: <a href="https://www.youtube.com/watch?v=v_1MnQjwWDc" target="_blank" rel="noreferrer noopener">watch</a></li>
            </ol>
          </details>

          <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
            <button id="toggleMaskBtn" type="button" class="redeem-btn">Show</button>
            <button id="pasteBtn" type="button" class="redeem-btn">Paste</button>
            <button id="clearBtn" type="button" class="redeem-btn">Clear</button>
          </div>

          <textarea id="tokenInput" class="redeem-input masked" placeholder="Account token" spellcheck="false" autocorrect="off" autocapitalize="off"></textarea>

          <div class="redeem-meta">
            <span id="tokenInfo">Chars: 0</span>
            <span id="tokenWarn">We do not store the token. It is used only for activation.</span>
          </div>
        </section>
      </div>

      <section id="actionsRow" class="redeem-actions">
        <button id="checkBtn" type="button" class="redeem-btn">Check status</button>
        <button id="retryNewKeyBtn" type="button" class="redeem-btn">Change key and retry</button>
        <button id="startBtn" type="button" class="redeem-btn redeem-btn-primary full" disabled>Activate</button>
        <button id="stopPollingBtn" type="button" class="redeem-btn full" style="display:none">Stop checking</button>
      </section>

      <section id="statusBox" class="redeem-status">
        <span id="statusText">Waiting for action.</span>
        <span id="statusSpinner" class="redeem-spinner" aria-hidden="true"></span>
        <span id="taskWrap" style="display:none">Task: <strong id="taskIdValue"></strong></span>
        <button id="copyTaskBtn" type="button" class="redeem-btn" style="display:none">Copy Task</button>
      </section>

      <section class="redeem-faq">
        Error? Check payment, <strong>order_id</strong> and try again.
      </section>
    </section>
  </main>

  <footer>
    <a class="footer-link" href="/oferta.html">��������� ������</a> � <a class="footer-link" href="/politika.html">�������� ������������������</a> � <a class="footer-link" href="/refund.html">������� ��������</a>
    <span class="footer-copy">� 2026 GPTishka. ��� ����� ��������, ����������� ���������.</span>
  </footer>

  <script src="/assets/js/app.min.js" defer></script>
  <script>
    const langSwitch = document.getElementById("langSwitch");
    const langCurrent = document.getElementById("langCurrent");

    langCurrent.addEventListener("click", () => {
      langSwitch.classList.toggle("open");
    });

    document.querySelectorAll(".lang-item").forEach(item => {
      item.addEventListener("click", () => {
        const lang = item.dataset.lang;
        if (lang === "en") window.location.href = "/en/redeem-start.html" + window.location.search;
        if (lang === "ru") window.location.href = "/redeem-start.html" + window.location.search;
      });
    });

    document.addEventListener("click", e => {
      if (!langSwitch.contains(e.target)) langSwitch.classList.remove("open");
    });
  </script>

  <script>
    const params = new URLSearchParams(window.location.search);
    const orderId = String(params.get('order_id') || params.get('orderId') || '').trim();
    let orderLinkToken = String(params.get('t') || '').trim();

    const orderIdEl = document.getElementById('orderId');
    const copyOrderIdBtn = document.getElementById('copyOrderIdBtn');
    const tokenInput = document.getElementById('tokenInput');
    const tokenInfo = document.getElementById('tokenInfo');
    const tokenWarn = document.getElementById('tokenWarn');
    const toggleMaskBtn = document.getElementById('toggleMaskBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const clearBtn = document.getElementById('clearBtn');
    const actionsRow = document.getElementById('actionsRow');

    const startBtn = document.getElementById('startBtn');
    const checkBtn = document.getElementById('checkBtn');
    const retryNewKeyBtn = document.getElementById('retryNewKeyBtn');
    const stopPollingBtn = document.getElementById('stopPollingBtn');

    const statusBox = document.getElementById('statusBox');
    const statusText = document.getElementById('statusText');
    const statusSpinner = document.getElementById('statusSpinner');
    const taskWrap = document.getElementById('taskWrap');
    const taskIdValue = document.getElementById('taskIdValue');
    const copyTaskBtn = document.getElementById('copyTaskBtn');

    const POLL_INTERVAL_MS = 2000;
    // Provider processing may take a few minutes. Don't auto-restart tasks on short timeouts.
    const POLL_MAX_MS = 5 * 60 * 1000;
    const RETRY_COOLDOWN_MS = 20000;
    const TOKEN_VALIDATE_DEBOUNCE_MS = 600;

    let currentTaskId = '';
    let pollTimer = null;
    let pollStartedAt = 0;
    let lastToken = '';
    let restartAttempts = 0;
    let isRetryRunning = false;
    let lastRetryAt = 0;
    let isMasked = true;
    let validateTimer = null;
    let tokenValidatedOk = false;
    let lastValidateReason = '';

    // By default, allow retry only after explicit failure or pending timeout.
    retryNewKeyBtn.disabled = true;

    const pollPauseKey = orderId ? `gptishka_activation_poll_paused:${orderId}` : '';

    function isPollPaused() {
      if (!pollPauseKey) return false;
      try { return localStorage.getItem(pollPauseKey) === '1'; } catch (_) { return false; }
    }

    function setPollPaused(paused) {
      if (!pollPauseKey) return;
      try { localStorage.setItem(pollPauseKey, paused ? '1' : '0'); } catch (_) {}
    }

    if (!orderId) {
      // Allow returning if the client closed the window but is in the same browser.
      try {
        const lastId = String(localStorage.getItem('gptishka_activation_order_id') || '').trim();
        const lastToken = lastId ? String(localStorage.getItem(`gptishka_activation_order_token:${lastId}`) || '').trim() : '';
        if (lastId && lastToken) {
          const url = new URL('/redeem-start.html', window.location.origin);
          url.searchParams.set('order_id', lastId);
          url.searchParams.set('t', lastToken);
          window.location.replace(url.toString());
        }
      } catch (_) {}

      setStatus('error', 'Missing order_id in the link.', false);
      startBtn.disabled = true;
      checkBtn.disabled = true;
      retryNewKeyBtn.disabled = true;
    } else {
      orderIdEl.textContent = orderId;
      try {
        localStorage.setItem('gptishka_activation_order_id', orderId);
        if (!orderLinkToken) {
          orderLinkToken = String(localStorage.getItem(`gptishka_activation_order_token:${orderId}`) || '').trim();
        }
        if (orderLinkToken) localStorage.setItem(`gptishka_activation_order_token:${orderId}`, orderLinkToken);
      } catch (_) {}
      loadActivation();
    }

    updateTokenMeta();
    scheduleValidateToken();

    tokenInput.addEventListener('input', () => {
      updateTokenMeta();
      scheduleValidateToken();
    });

    toggleMaskBtn.addEventListener('click', () => {
      isMasked = !isMasked;
      tokenInput.classList.toggle('masked', isMasked);
      toggleMaskBtn.textContent = isMasked ? 'Show' : 'Hide';
    });

    pasteBtn.addEventListener('click', async () => {
      try {
        const clipboard = await navigator.clipboard.readText();
        if (clipboard) {
          tokenInput.value = clipboard;
          updateTokenMeta();
          scheduleValidateToken();
          setStatus('success', 'Token pasted', false);
        }
      } catch {
        setStatus('error', 'Failed to paste from clipboard', false);
      }
    });

    clearBtn.addEventListener('click', () => {
      tokenInput.value = '';
      updateTokenMeta();
      scheduleValidateToken();
      setStatus('pending', 'Cleared', false);
    });

    copyOrderIdBtn.addEventListener('click', () => copyText(orderId, 'Order ID copied'));
    copyTaskBtn.addEventListener('click', () => copyText(currentTaskId, 'Task ID copied'));

    startBtn.addEventListener('click', async () => {
      const token = getTokenForSubmit();
      if (!token) return;

      // Don't start if token is clearly invalid/expired.
      const validated = await validateTokenNow();
      if (!validated) return;

      setPollPaused(false);
      lastToken = token;
      restartAttempts = 0;
      setButtonLoading(startBtn, true);
      try {
        setStatus('pending', 'Request sent...', true);
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token, orderToken: orderLinkToken }),
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          let details = '';
          if (payload?.details) {
            try {
              details = typeof payload.details === 'string' ? payload.details : JSON.stringify(payload.details);
            } catch (_) {
              details = '';
            }
          }
          details = String(details || '').trim();
          if (details.length > 400) details = details.slice(0, 400) + '...';
          setStatus('error', (payload?.message || 'Failed to start activation') + (details ? `: ${details}` : ''), false);
          return;
        }
        currentTaskId = String(payload.taskId || '');
        renderTask(currentTaskId);
        setStatus('pending', `Processing. Task: ${currentTaskId}`, true);
        startPolling();
      } catch {
        setStatus('error', 'Network error while starting activation', false);
      } finally {
        setButtonLoading(startBtn, false);
      }
    });

    checkBtn.addEventListener('click', async () => {
      if (!currentTaskId) {
        setStatus('pending', 'Start activation first', false);
        return;
      }
      setButtonLoading(checkBtn, true);
      await checkTaskStatus();
      setButtonLoading(checkBtn, false);
    });

    retryNewKeyBtn.addEventListener('click', async () => {
      if (isRetryRunning) return;
      const now = Date.now();
      const remain = RETRY_COOLDOWN_MS - (now - lastRetryAt);
      if (remain > 0) {
        setStatus('error', `Too often. Try again in ${Math.ceil(remain / 1000)} sec.`, false);
        return;
      }

      const token = getTokenForSubmit();
      if (!token) {
        setStatus('error', 'Enter token', false);
        return;
      }

      const validated = await validateTokenNow();
      if (!validated) return;

      setPollPaused(false);
      lastRetryAt = now;
      lastToken = token;
      restartAttempts = 0;
      isRetryRunning = true;
      setButtonLoading(retryNewKeyBtn, true);
      try {
        setStatus('pending', 'Getting a new key and retrying...', true);
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation/restart-with-new-key`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token, orderToken: orderLinkToken }),
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          setStatus('error', payload?.message || 'Failed to retry', false);
          return;
        }
        currentTaskId = String(payload.taskId || '');
        renderTask(currentTaskId);
        setStatus('pending', `Processing. Task: ${currentTaskId}`, true);
        startPolling();
      } catch {
        setStatus('error', 'Network error while retrying', false);
      } finally {
        isRetryRunning = false;
        setButtonLoading(retryNewKeyBtn, false);
      }
    });

    stopPollingBtn.addEventListener('click', () => {
      stopPolling();
      setPollPaused(true);
      setStatus('pending', 'Auto-check stopped', false);
    });

    async function loadActivation() {
      try {
        const suffix = orderLinkToken ? `?t=${encodeURIComponent(orderLinkToken)}` : '';
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation${suffix}`);
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          setStatus('error', payload?.message || 'Failed to load activation status', false);
          return;
        }
        currentTaskId = String(payload.taskId || '');
        renderTask(currentTaskId);
        if (currentTaskId) {
          if (isPollPaused()) {
            setStatus('pending', `There is an active check. Task: ${currentTaskId}. Auto-check is stopped.`, false);
          } else {
            setStatus('pending', `Processing. Task: ${currentTaskId}`, true);
            startPolling();
          }
          return;
        }
        setStatus('pending', 'Waiting for action.', false);
      } catch {
        setStatus('error', 'Network error while loading activation', false);
      }
    }

    function startPolling() {
      stopPolling();
      setPollPaused(false);
      stopPollingBtn.style.display = 'inline-flex';
      pollStartedAt = Date.now();
      pollTimer = setInterval(async () => {
        const done = await checkTaskStatus();
        const timeout = Date.now() - pollStartedAt >= POLL_MAX_MS;
        if (done || timeout) {
          stopPolling();
          if (!done && timeout) {
            setStatus('pending', `Still processing. Task: ${currentTaskId}. Click �Check status� later or �Change key and retry�.`, false);
            retryNewKeyBtn.disabled = false;
          }
        }
      }, POLL_INTERVAL_MS);
    }

    function stopPolling() {
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
      stopPollingBtn.style.display = 'none';
    }

    async function checkTaskStatus() {
      try {
        const suffix = orderLinkToken ? `?t=${encodeURIComponent(orderLinkToken)}` : '';
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation/task/${encodeURIComponent(currentTaskId)}${suffix}`);
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          setStatus('error', payload?.message || 'Failed to get status', false);
          return true;
        }

        if (payload.pending) {
          const msg = String(payload?.message || '').trim();
          setStatus('pending', `Processing. Task: ${currentTaskId}${msg ? `. ${msg}` : ''}`, true);
          retryNewKeyBtn.disabled = true;
          return false;
        }

        if (payload.success) {
          setStatus('success', `Success. Task: ${currentTaskId}`, false);
          hideActionButtons();
          return true;
        }

        setStatus('error', payload?.message || 'Request failed', false);
        retryNewKeyBtn.disabled = false;
        return true;
      } catch {
        setStatus('error', 'Network error while checking status', false);
        return false;
      }
    }

    async function restartActivation() {
      try {
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: lastToken }),
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) return false;
        const nextTask = String(payload.taskId || '').trim();
        if (!nextTask) return false;
        currentTaskId = nextTask;
        renderTask(currentTaskId);
        return true;
      } catch {
        return false;
      }
    }

    function renderTask(taskId) {
      const value = String(taskId || '').trim();
      if (!value) {
        taskWrap.style.display = 'none';
        copyTaskBtn.style.display = 'none';
        taskIdValue.textContent = '';
        return;
      }
      taskIdValue.textContent = value;
      taskWrap.style.display = 'inline-flex';
      copyTaskBtn.style.display = 'inline-flex';
    }

    function hideActionButtons() {
      stopPolling();
      actionsRow.style.display = 'none';
    }

    function updateTokenMeta() {
      const raw = String(tokenInput.value || '').trim();
      const token = extractTokenFromInput(raw);
      const length = token.length;
      tokenInfo.textContent = `Chars: ${length}`;
      if (raw.startsWith('{') && token && token !== raw) {
        tokenWarn.textContent = 'JSON detected: extracted token will be used.';
      } else {
        tokenWarn.textContent = 'We do not store the token. It is used only for activation.';
      }
      tokenWarn.className = '';
    }

    function updateStartButtonState() {
      const hasValue = Boolean(orderId && String(tokenInput.value || '').trim());
      startBtn.disabled = !hasValue || !tokenValidatedOk;
    }

    function scheduleValidateToken() {
      tokenValidatedOk = false;
      lastValidateReason = '';
      updateStartButtonState();

      if (validateTimer) clearTimeout(validateTimer);
      validateTimer = setTimeout(() => {
        validateTokenNow();
      }, TOKEN_VALIDATE_DEBOUNCE_MS);
    }

    async function validateTokenNow() {
      const token = getTokenForSubmit();
      if (!orderId || !token) {
        tokenValidatedOk = false;
        lastValidateReason = 'Enter token';
        tokenWarn.textContent = lastValidateReason;
        tokenWarn.className = 'warn';
        updateStartButtonState();
        return false;
      }

      try {
        const response = await fetch(`/api/orders/${encodeURIComponent(orderId)}/activation/validate-token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token, orderToken: orderLinkToken }),
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          tokenValidatedOk = false;
          lastValidateReason = payload?.message || 'Failed to validate token';
          tokenWarn.textContent = lastValidateReason;
          tokenWarn.className = 'warn';
          updateStartButtonState();
          return false;
        }

        const ok = Boolean(payload?.ok);
        const reasons = Array.isArray(payload?.reasons) ? payload.reasons : [];
        tokenValidatedOk = ok;
        lastValidateReason = reasons.join('; ');

        if (ok) {
          tokenWarn.textContent = 'Token format looks valid (not stored).';
          tokenWarn.className = '';
        } else {
          tokenWarn.textContent = lastValidateReason || 'Token is not valid';
          tokenWarn.className = 'warn';
        }

        updateStartButtonState();
        return ok;
      } catch {
        tokenValidatedOk = false;
        lastValidateReason = 'Network error while validating token';
        tokenWarn.textContent = lastValidateReason;
        tokenWarn.className = 'warn';
        updateStartButtonState();
        return false;
      }
    }

    function getTokenForSubmit() {
      // Send raw input to backend; backend handles JSON vs token formats and retries safely.
      return String(tokenInput.value || '').trim();
    }

    function extractTokenFromInput(raw) {
      const value = String(raw || '').trim();
      if (!value || !value.startsWith('{')) return value;

      try {
        const parsed = JSON.parse(value);
        if (typeof parsed?.accessToken === 'string' && parsed.accessToken.trim()) {
          return parsed.accessToken.trim();
        }
        if (typeof parsed?.sessionToken === 'string' && parsed.sessionToken.trim()) {
          return parsed.sessionToken.trim();
        }
        if (typeof parsed?.token === 'string' && parsed.token.trim()) {
          return parsed.token.trim();
        }
      } catch (_) {
        return value;
      }

      return value;
    }

    function setStatus(tone, text, loading) {
      statusBox.className = `redeem-status ${tone}`;
      statusText.textContent = text;
      statusSpinner.style.display = loading ? 'inline-block' : 'none';
    }

    function setButtonLoading(btn, loading) {
      btn.classList.toggle('loading', Boolean(loading));
      btn.disabled = Boolean(loading);
      if (btn === startBtn && !loading) {
        updateStartButtonState();
      }
    }

    async function copyText(value, okMessage) {
      const text = String(value || '').trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        setStatus('success', okMessage, false);
      } catch {
        setStatus('error', 'Copy failed', false);
      }
    }
  </script>
</body>
</html>

